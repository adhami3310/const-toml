//! Statically include TOML files.
//!
//! Using this crate it is easy to statically embed data from TOML files at compile time.
//! The provided macro [`static_toml!`] will generate the necessary data types to construct a
//! static representation of the TOML file.
//!
//! # Usage
//! Including a TOML file is simple.
//! Here's how to include the version string defined in the `Cargo.toml`:
//! ```
//! static_toml::static_toml! {
//!     static CARGO_MANIFEST = include_toml!("Cargo.toml");
//! }
//!
//! static VERSION: &str = CARGO_MANIFEST.package.version;
//! ```
//! Accessing the values of nested data structures works by using the dot notation.
//! IDEs capable to expanding proc macros
//! (e.g. VS Code with rust-analyzer or CLion with the Rust plugin)
//! should be able to provide code completion of the included TOML file.
//!
//! # Syntax
//! The syntax is defined to be intuitive:
//! ```ignore
//! static_toml::static_toml! {
//!     [pub] static NAME_1 = include_toml!("file_1.toml");
//!     [pub] static NAME_2 = include_toml!("file_2.toml");
//!     ...
//!     [pub] static NAME_N = include_toml!("file_n.toml");
//! }
//! ```
//! *Note*:
//! Even though this syntax looks like a typical static value coming from a `include_*!` macro call,
//! the data type is omitted as it is generated by the [`static_toml!`] macro call.
//!
//! Instead of `pub` other visibilities may also be used.
//! The passed visibility will automatically applied to both, the root module of the generated data
//! types and the static value.
//! For possible values, check
//! [**Visibility and Privacy** in The Rust Reference](https://doc.rust-lang.org/stable/reference/visibility-and-privacy.html).
//!
//! Attributes (including doc comments) are also supported:
//! ```
//! static_toml::static_toml! {
//!     /// doc comments are supported
//!     #[allow(missing_docs)]
//!     #[derive(Debug)]
//!     static EXAMPLE = include_toml!("example.toml");
//! }
//! ```
//! Doc comments will be attached to the generated static value.
//! Derive attributes will be propagated through every constructed data type, allowing to use
//! derive macros like [`Default`] to be used.
//! Other attributes will be attached to the root module containing the entry point of the
//! generated data types.
//!
//! # Arrays
//! Arrays in a TOML file are allowed to have different data types for each item in that array.
//! Rust's slices only allow a single data type to be used in the entire array.
//! Since this crate is designed to make accessing the data of a TOML file as easy as possible, the
//! handling of array must not include [`Options`](Option).
//!
//! Instead the macro will analyze whether each item of an array has *exactly* the same data type.
//! If so, it will generate a fix-sized slice of that data type.
//! This allows iterating of over the array and indexing via `[n]`.
//!
//! If the data types do not match exactly, a tuple will be generated which allows for each
//! position to have a different data type.
//! This will happen when at least one item doesn't have the exact data type structure as the
//! others.
//! Still indexing such a type is easy, as tuples may be directly indexed via `.n`.
//!
//! # Configuration
//! The macro call can be configured by applying a `static_toml` attribute to the to be configured
//! items.
//!
//! - `#[static_toml(prefix = Prefix)]`
//!
//!   Every generated data type will be prefixed by this prefix.
//!   The prefix needs to be a valid rust identifier and will be prefixed as is.
//!
//!   <br>
//!
//! - `#[static_toml(suffix = Suffix)]`
//!
//!   Just like the prefix but as suffix.
//!
//!   <br>
//!
//! - `#[static_toml(root_mod = toml)]`
//!
//!   Identifier of the root module that will contain the datatypes for the TOML file.
//!   If this is not set the name of static value will be converted to `snake_case` and used a root
//!   mod name.
//!
//!   <br>
//!
//! - `#[static_toml(values_ident = values)]`
//!
//!   When generating the value types for arrays, they need their own namespace.
//!   By default this macro will use `values` for naming the modules and data types.
//!
//!   <br>
//!
//! - `#[static_toml(prefer_slices = true)]`
//!
//!   Set whether the macro should try to generate fixed size slices when working with arrays.
//!   If the setting is set to `false` the macro will generate tuples for every array.
//!   By default this is set to `true`.
//!
//! Combining attributes is also possible:
//! ```
//! static_toml::static_toml! {
//!     // all data types will be prefixed, suffixed and derive Default
//!     #[derive(Default)]
//!     #[static_toml(prefix = Prefix, suffix = Suffix)]
//!     static EXAMPLE = include_toml!("example.toml");
//! }
//! ```
//!
//! # Implementation Details
//! For the little specific details, check the documentation for [`static_toml!`].

extern crate proc_macro;

use std::path::PathBuf;
use std::{env, fs};

use convert_case::{Case, Casing};
use proc_macro::TokenStream;
use proc_macro2::TokenStream as TokenStream2;
use quote::{format_ident, quote, ToTokens};
use toml::value::{Table, Value};

use crate::parse::{StaticToml, StaticTomlItem};
use crate::toml_tokens::{fixed_ident, TomlTokens};

mod parse;
mod toml_tokens;

#[proc_macro]
pub fn static_toml(input: TokenStream) -> TokenStream {
    let token_stream2 = TokenStream2::from(input);
    static_toml2(token_stream2).into()
}

fn static_toml2(input: TokenStream2) -> TokenStream2 {
    let static_toml_data: StaticToml = syn::parse2(input).unwrap();

    static_toml_data
        .0
        .iter()
        .map(|static_toml| {
            let mut file_path = PathBuf::new();
            file_path.push(env::var("CARGO_MANIFEST_DIR").unwrap());
            file_path.push(static_toml.path.value());
            let include_file_path = file_path.to_str().unwrap();

            let content = fs::read_to_string(&file_path).unwrap();
            let table: Table = toml::from_str(&content).unwrap();
            let value_table = Value::Table(table);

            let root_mod = static_toml.attrs.root_mod.clone().unwrap_or(format_ident!(
                "{}",
                static_toml.name.to_string().to_case(Case::Snake)
            ));
            let mut namespace = vec![root_mod.clone()];
            let visibility = static_toml
                .visibility
                .as_ref()
                .map(|vis| vis.to_token_stream())
                .unwrap_or_default();
            let static_tokens = value_table.static_tokens(
                root_mod.to_string().as_str(),
                &static_toml.attrs,
                &mut namespace
            );
            let type_tokens = value_table.type_tokens(
                root_mod.to_string().as_str(),
                &static_toml.attrs,
                visibility,
                &static_toml.derive
            );

            let name = &static_toml.name;
            let root_type = fixed_ident(
                root_mod.to_string().as_str(),
                &static_toml.attrs.prefix,
                &static_toml.attrs.suffix
            );

            let StaticTomlItem {
                doc,
                other_attrs,
                visibility,
                ..
            } = static_toml;

            quote! {
                #(#doc)*
                #visibility static #name: #root_mod::#root_type = #static_tokens;

                #(#other_attrs)*
                #type_tokens

                // trick to re-evaluate macro call when included file changed
                const _: &str = include_str!(#include_file_path);
            }
        })
        .collect()
}
